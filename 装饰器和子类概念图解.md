# 装饰器和子类概念图解

## 问题1：为什么装饰器要写在类上面？

### 答案：因为 Python 从上往下执行代码

```
┌──────────────────────────────────────────────────┐
│  Python 执行顺序：从上到下                         │
└──────────────────────────────────────────────────┘

第1行 →  @RobotConfig.register_subclass("so101")
         ↓ Python 读到这里，先记住装饰器
         │
第2行 →  class SO101Config(RobotConfig):
         ↓ Python 读到这里，创建类
         │
第3行 →      pass
         ↓ Python 创建完成，应用装饰器
```

### 等价代码

```python
# 使用 @ 语法（推荐）
@RobotConfig.register_subclass("so101")
class SO101Config(RobotConfig):
    pass

# 等价于（不推荐，但更容易理解）
class SO101Config(RobotConfig):
    pass
SO101Config = RobotConfig.register_subclass("so101")(SO101Config)
                        ↑ 装饰器就是一个函数调用
```

### 为什么不能反过来？

```python
❌ 错误写法（Python 不允许）：

class SO101Config(RobotConfig):
    pass
@RobotConfig.register_subclass("so101")  # ← 装饰器不能在类下面

# 这不是有效的 Python 语法！
```

---

## 问题2：subclass 是什么？

### 答案：subclass = 子类（继承关系）

```
┌─────────────────────────────────────────────────┐
│           继承关系（家族树）                      │
└─────────────────────────────────────────────────┘

            Animal            ← 父类 (Parent/Super/Base Class)
              │
        ┌─────┴─────┐
        │           │
       Dog         Cat        ← 子类 (Child/Sub/Derived Class)


说法：
  • Dog 是 Animal 的子类
  • Cat 是 Animal 的子类
  • Animal 是 Dog 的父类
  • Animal 是 Cat 的父类
```

### 代码示例

```python
# 父类
class Animal:
    pass

# 子类
class Dog(Animal):    # Dog 继承 Animal
    pass              # Dog 是 Animal 的 subclass（子类）

class Cat(Animal):    # Cat 继承 Animal
    pass              # Cat 是 Animal 的 subclass（子类）

# 验证
issubclass(Dog, Animal)  # → True（Dog 是 Animal 的子类）
issubclass(Cat, Animal)  # → True（Cat 是 Animal 的子类）
```

---

## 把两个概念结合：register_subclass

### 名字拆解

```
register_subclass
    ↓         ↓
  注册      子类

完整含义：注册子类
```

### 为什么叫 "register_subclass"？

```
因为我们要注册的是 RobotConfig 的子类！

    RobotConfig              ← 父类
         │
    ┌────┼────┬────┐
    │    │    │    │
  SO101 SO100 Koch ...       ← 子类（subclass）
  Config Config Config

register_subclass 的作用：
  把这些子类注册到父类的注册表中
```

---

## 完整流程图

```
┌──────────────────────────────────────────────────────────────┐
│                   代码和执行流程                               │
└──────────────────────────────────────────────────────────────┘

代码：
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    @RobotConfig.register_subclass("so101")   ← 装饰器
    class SO101Config(RobotConfig):           ← 类定义
        pass

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

执行流程：
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

步骤1: Python 读装饰器
    @RobotConfig.register_subclass("so101")
    │
    ├─► 调用 register_subclass("so101")
    │
    └─► 返回 decorator 函数

步骤2: Python 读类定义
    class SO101Config(RobotConfig):
        pass
    │
    ├─► 创建类 SO101Config
    │
    └─► 继承关系：SO101Config 是 RobotConfig 的子类 ✓

步骤3: Python 应用装饰器
    decorator(SO101Config)
    │
    ├─► 检查：是子类吗？ ✓
    │
    ├─► 注册：_registry["so101"] = SO101Config
    │
    └─► 返回 SO101Config

步骤4: 完成
    SO101Config 已注册到注册表

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## 位置关系总结

### ✅ 正确的写法

```python
@RobotConfig.register_subclass("so101")    ← 装饰器在上
class SO101Config(RobotConfig):            ← 类在下
    pass

原因：
  1. Python 从上往下读代码
  2. 需要先知道装饰器是什么
  3. 然后创建类
  4. 最后用装饰器包装类
```

### ❌ 错误的写法

```python
class SO101Config(RobotConfig):            ← 类在上
    pass
@RobotConfig.register_subclass("so101")    ← 装饰器在下

错误：
  ❌ Python 不允许这样写
  ❌ 装饰器必须紧贴在被装饰对象的上面
```

---

## 关键术语对照表

| 中文 | 英文 | 例子 |
|-----|------|-----|
| 父类 | Parent Class | RobotConfig |
| 基类 | Base Class | RobotConfig |
| 超类 | Super Class | RobotConfig |
| **子类** | **Sub Class** | **SO101Config** |
| 派生类 | Derived Class | SO101Config |
| 装饰器 | Decorator | @register_subclass |
| 注册 | Register | 添加到注册表 |

---

## 快速记忆口诀

```
装饰器在上，类在下
子类继承父类，register_subclass 来注册
Python 从上往下跑，位置顺序不能搞
```

---

## 实际应用

在你的项目中：

```python
# 文件：config_so101_follower.py

from ..config import RobotConfig

@RobotConfig.register_subclass("so101_follower")  # ← 注册子类
class SO101FollowerConfig(RobotConfig):           # ← SO101FollowerConfig 是子类
    port: str                                     # ← RobotConfig 是父类

继承关系：
  RobotConfig (父类)
       ↓ 继承
  SO101FollowerConfig (子类)

作用：
  把 SO101FollowerConfig 注册为名字 "so101_follower"
  这样命令行输入 --robot.type=so101_follower 时
  就能找到并创建 SO101FollowerConfig 实例
```

